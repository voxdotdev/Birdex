<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Birdex</title>
  <style>
    :root {
      --bg: #f6f3ff;
      --tile: #e7e2fb;
      --tile-seen: #c7f0d8;
      --tile-missing: #e8e8ef;
      --tile-hover: #d7d1ff;
      --text: #2a1f4d;
      --muted: #7a7396;
      --accent: #6c5ce7;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    .wrap {
      max-width: 1400px;
      margin: 0 auto;
      padding: 16px 16px 80px;
      position: relative;
    }

    .bar {
      position: sticky;
      top: 0;
      background: linear-gradient(180deg, rgba(255, 255, 255, .9), rgba(255, 255, 255, .5));
      backdrop-filter: blur(6px);
      z-index: 5;
      border-bottom: 1px solid #fff;
    }

    .bar .inner {
      max-width: 1400px;
      margin: 0 auto;
      padding: 10px 16px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap
    }

    .badge {
      background: white;
      color: var(--accent);
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 600;
      font-size: 12px;
      border: 1px solid #ede9fe
    }

    .counts {
      margin-left: auto;
      display: flex;
      gap: 8px
    }
    .header-actions { display: flex; gap: 8px; }

    .chip {
      background: var(--tile);
      border-radius: 12px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
    }
    .chip.active {
      background: var(--accent);
      color: #fff;
    }

    .search {
      flex: 1 1 220px;
      display: flex;
      gap: 8px
    }

    .search input,
    .search select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ded8ff;
      border-radius: 10px;
      background: white
    }

    /* Grid and tiles */
    .grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 14px;
      margin-top: 14px
    }

    /* Layout wrapper: grid + details pane */
    .main { display: flex; align-items: flex-start; gap: 16px; }
    .grid { flex: 1 1 0; min-width: 0; }
    .details { width: 450px; background: rgb(255, 255, 255); border: 1px solid #dadada; border-radius: 12px; padding: 12px; position: fixed; right: 40px; top: 88px; max-height: calc(100vh - 104px ); overflow:hidden; }
    .details .pane-title { font-weight: 700; margin-bottom: 8px; }
    .details .pane-photo { width: 100%; aspect-ratio: 1/1; background: rgb(232, 232, 237); background-size: cover; background-position: center; border: 1px solid rgb(221, 221, 221); border-radius: 8px; margin-bottom: 10px; }

    .tile {
      position: relative;
      aspect-ratio: 3/4;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid #ddd;
      box-shadow: 0 1px 2px rgba(0, 0, 0, .03);
      background: var(--tile);
      cursor: pointer;
      transition: transform .05s ease, box-shadow .1s ease, background .15s ease;
      perspective: 1000px
    }

    .tile:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, .06);
      background: var(--tile-hover)
    }

    .tile.seen {
      background: var(--tile-seen);
    }
    .tile.observed {
      background: #eaf5ff;
    }

    /* seen now means: has a photo */
    .tile.missing {
      background: var(--tile-missing);
      filter: saturate(.7)
    }

    /* Flip card inner */
    .card {
      position: absolute;
      inset: 0;
      transform-style: preserve-3d;
      transition: transform .4s ease
    }

    .tile.flipped .card {
      transform: rotateY(180deg)
    }

    .face {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      display: flex;
      flex-direction: column
    }

    /* FRONT */
    .front .content {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .photobox {
      flex: 1;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      width: 100%;
      height: 100%
    }

    .front img {
      width: 100%;
      height: 100%;
      object-fit: cover
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      font-size: 12px;
      line-height: 1.2;
      color: #4b426e;
      font-weight: 600;
      background: rgba(255, 255, 255, .85);
      backdrop-filter: blur(3px)
    }

    .name {
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      flex: 1
    }

    .idx {
      color: #635b85;
      font-weight: 700;
      margin-left: 8px
    }

    /* Front footer: group number + name on left */
    .header .left { display: flex; align-items: center; gap: 8px; }
    .header .left .idx { margin-left: 0; margin-right: 8px; }
    .header .left .name { flex: 0 1 auto; }

    .sil {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 40px;
      opacity: .5
    }

    /* BACK */
    .back {
      transform: rotateY(180deg);
      background: white
    }

    .back .top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      padding: 10px;
      border-bottom: 1px solid #eee
    }

    .back .title {
      font-weight: 700
    }

    .back .body {
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1;
      overflow: hidden;
    }

    .field .label {
      font-size: 12px;
      color: #6b6683;
      font-weight: 600;
      margin-right: 6px;
      white-space: nowrap;
    }

    .field {
      display: flex;
      align-items: baseline;
      gap: 6px;
      margin: 0;
    }

    .field .value {
      font-size: 12px;
      line-height: 1.35;
      color: #2a1f4d;
    }

    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px
    }

    .dot {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid #ddd
    }

    .dot.seen {
      background: var(--tile-seen)
    }

    .dot.missing {
      background: var(--tile-missing)
    }
    .dot.observed {
      background: #eaf5ff
    }

    .actions {
      position: fixed;
      right: 16px;
      bottom: 16px;
      display: flex;
      gap: 8px
    }

    .btn {
      background: var(--accent);
      border: none;
      color: white;
      padding: 6px 8px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 700;
      box-shadow: 0 10px 24px rgba(108, 92, 231, .24);
      cursor: pointer
    }

    .btn.secondary {
      background: white;
      color: var(--accent);
      border: 1px solid #ded8ff
    }
    .icons { display: flex; margin-left: auto; }
    .iconbtn { background: transparent; border: 1px solid transparent; color: #4b426e; padding: 4px; border-radius: 8px; line-height: 0; cursor: default; }
    .iconbtn:hover { background: rgba(0,0,0,.05); border-color: rgba(0,0,0,.06); }
    .iconbtn svg { width: 16px; height: 16px; display: block; }
    .back .header { margin-top: auto; border-top: 1px solid #eee; }
    /* Remove drop shadow for header action buttons */
    .header-actions .btn { box-shadow: none; }
  </style>
  <script>
    // Minimal EXIF reader for JPEG APP1 (Exif) used for our fields only
    // Parses: Make(0x010F), Model(0x0110), ExifIFDPointer(0x8769),
    // DateTimeOriginal(0x9003), FNumber(0x829D), ExposureTime(0x829A),
    // ISOSpeedRatings(0x8827), PhotographicSensitivity(0x8830),
    // ShutterSpeedValue(0x9201), ApertureValue(0x9202), FocalLength(0x920A),
    // FocalLengthIn35mmFormat(0xA405)
    async function parseEXIF(buffer) {
      const view = new DataView(buffer);
      const len = view.byteLength;
      let off = 0;
      // Validate SOI
      if (len < 4 || view.getUint16(0, false) !== 0xFFD8) return null;
      off = 2;
      // iterate JPEG segments
      while (off + 4 <= len) {
        if (view.getUint8(off) !== 0xFF) return null;
        const marker = view.getUint8(off + 1);
        off += 2;
        if (marker === 0xD9 || marker === 0xDA) break; // EOI or SOS
        const size = view.getUint16(off, false); // includes length bytes
        const segStart = off + 2;
        if (marker === 0xE1 && size >= 8) { // APP1
          // Check Exif header
          const isExif =
            String.fromCharCode(
              view.getUint8(segStart + 0), view.getUint8(segStart + 1), view.getUint8(segStart + 2),
              view.getUint8(segStart + 3), view.getUint8(segStart + 4), view.getUint8(segStart + 5)
            ) === 'Exif\u0000\u0000';
          if (!isExif) { off += size; continue; }
          const tiffStart = segStart + 6;
          const le = (view.getUint16(tiffStart, false) === 0x4949);
          const get16 = (p) => view.getUint16(p, le);
          const get32 = (p) => view.getUint32(p, le);
          const readAscii = (p, c) => {
            let s = '';
            for (let i = 0; i < c && p + i < len; i++) {
              const ch = view.getUint8(p + i); if (!ch) break; s += String.fromCharCode(ch);
            }
            return s;
          };
          const readRational = (p, signed = false) => {
            const n = signed ? view.getInt32(p, le) : view.getUint32(p, le);
            const d = signed ? view.getInt32(p + 4, le) : view.getUint32(p + 4, le);
            if (!d) return 0; return n / d;
          };
          const readValue = (type, count, valOff) => {
            const typeSize = { 1:1, 2:1, 3:2, 4:4, 5:8, 7:1, 9:4, 10:8 }[type] || 1;
            const bytes = count * typeSize;
            const dataOff = bytes > 4 ? tiffStart + valOff : (tiffStart + 8 /*header*/ + 0 /*dummy*/);
            const start = bytes > 4 ? dataOff : null;
            switch (type) {
              case 2: { // ASCII
                if (bytes > 4) return readAscii(start, count);
                // value packed into valOff
                const arr = [];
                for (let i = 0; i < 4; i++) arr.push((valOff >> ((3 - i) * 8)) & 0xFF);
                return String.fromCharCode(...arr).replace(/\u0000.*$/, '');
              }
              case 3: { // SHORT
                if (bytes <= 4) return valOff & 0xFFFF;
                const v = [];
                for (let i = 0; i < count; i++) v.push(get16(start + i * 2));
                return count === 1 ? v[0] : v;
              }
              case 4: { // LONG
                if (bytes <= 4) return valOff >>> 0;
                const v = [];
                for (let i = 0; i < count; i++) v.push(get32(start + i * 4));
                return count === 1 ? v[0] : v;
              }
              case 5: { // RATIONAL
                if (count === 1) return readRational(start, false);
                const v = [];
                for (let i = 0; i < count; i++) v.push(readRational(start + i * 8, false));
                return v;
              }
              case 10: { // SRATIONAL
                if (count === 1) return readRational(start, true);
                const v = [];
                for (let i = 0; i < count; i++) v.push(readRational(start + i * 8, true));
                return v;
              }
              default:
                return null;
            }
          };

          const readIFD = (offsetRel) => {
            const out = { tags: {}, next: 0 };
            let p = tiffStart + offsetRel;
            const num = get16(p); p += 2;
            for (let i = 0; i < num; i++) {
              const tag = get16(p); const type = get16(p + 2); const count = get32(p + 4); const valOff = get32(p + 8); p += 12;
              out.tags[tag] = { type, count, val: readValue(type, count, valOff) };
            }
            out.next = get32(p);
            return out;
          };

          const ifd0 = readIFD(get32(tiffStart + 4));
          const exifPtr = ifd0.tags[0x8769]?.val || 0;
          const res = {
            Make: ifd0.tags[0x010F]?.val || '',
            Model: ifd0.tags[0x0110]?.val || ''
          };
          if (exifPtr) {
            const exifIFD = readIFD(exifPtr);
            const g = (tag) => exifIFD.tags[tag]?.val;
            Object.assign(res, {
              DateTimeOriginal: g(0x9003) || '',
              FNumber: g(0x829D),
              ExposureTime: g(0x829A),
              ISO: g(0x8827) || g(0x8830),
              ShutterSpeedValue: g(0x9201),
              ApertureValue: g(0x9202),
              FocalLength: g(0x920A),
              FocalLengthIn35mmFormat: g(0xA405)
            });
          }
          return res;
        }
        off += size;
      }
      return null;
    }
  </script>
</head>

<body>
  <div class="bar">
    <div class="inner">
      <div class="badge">Bird Pokédex</div>
      <div class="search">
        <input id="q" placeholder="Search species... (e.g., 'warbler')" />
      </div>
      <div class="counts">
        <div class="chip" id="countCaptured">Captured: 0</div>
        <div class="chip" id="countSeen">Seen: 0</div>
        <div class="chip" id="countMissing">Missing: 0</div>
        <div class="chip" id="countTotal">Total: 0</div>
      </div>
      <div class="header-actions">
        <button class="btn secondary" id="exportBtn" title="Download your current data">Export Data</button>
        <button class="btn" id="importBtn">Import Data</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="legend">
      <div class="dot seen"></div> Captured (has a photo)
      <div class="dot observed"></div> Seen (no photo)
      <div class="dot missing"></div> Missing (not seen)
      <span style="margin-left:auto">Tip: left‑click a tile to add/change a photo. **Right‑click** flips the card to
        details.</span>
    </div>

    <div class="main">
      <div id="grid" class="grid" aria-live="polite"></div>
      <aside id="details" class="details" aria-live="polite" style="display:none;"></aside>
    </div>
  </div>

  

  <script src="species_data.js"></script>
  <script>
    // SPECIES is provided by species_data.js, generated from us-al_ebird_species.xlsx

    const STORAGE_KEY = 'birdpokedex_seen_v1';
    const PHOTO_KEY = 'birdpokedex_photos_v1';
    const META_KEY = 'birdpokedex_meta_v1';

    let photos = JSON.parse(localStorage.getItem(PHOTO_KEY) || '{}');
    let metadata = JSON.parse(localStorage.getItem(META_KEY) || '{}');
    let seen = new Set(JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'));
    const DEFAULT_DATA_URL = 'default-data.json'; // optional seed file checked into the repo

    const grid = document.getElementById('grid');
    const q = document.getElementById('q');
    const cCaptured = document.getElementById('countCaptured');
    const cSeen = document.getElementById('countSeen');
    const cMissing = document.getElementById('countMissing');
    const cTotal = document.getElementById('countTotal');
    let filterMode = null; // 'captured' | 'seen' | 'missing' | null
    const details = document.getElementById('details');
    let selectedCode = null; // species code currently shown in details pane

    function updateChips() {
      const set = (el, on) => { if (!el) return; el.classList.toggle('active', !!on); };
      set(cCaptured, filterMode === 'captured');
      set(cSeen, filterMode === 'seen');
      set(cMissing, filterMode === 'missing');
      // Total is a reset; not shown as active
    }

    function renderDetails() {
      if (!details) return;
      if (!selectedCode) { details.style.display = 'none'; details.innerHTML = ''; return; }
      const sp = SPECIES.find(s => s.code === selectedCode);
      if (!sp) { details.style.display = 'none'; details.innerHTML = ''; return; }
      const photo = photos[sp.code] || '';
      const photoHtml = photo
        ? `<div class="pane-photo" style="background-image:url('${photo}')"></div>`
        : `<div class="pane-photo" style="display:flex;align-items:center;justify-content:center;color:#6b6683;">No photo yet</div>`;
      const desc = (sp.description || '').trim();
      details.style.display = 'block';
      details.innerHTML = `
        <div class="pane-title">${sp.name}</div>
        ${photoHtml}
        <div class="desc">${desc || '<em style="color:#6b6683">No description available.</em>'}</div>
      `;
    }

    function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(Array.from(seen)));
      localStorage.setItem(PHOTO_KEY, JSON.stringify(photos));
      localStorage.setItem(META_KEY, JSON.stringify(metadata));
    }

    function pickFile(cb) {
      const inp = document.createElement('input');
      inp.type = 'file'; inp.accept = 'image/*';
      inp.onchange = ev => {
        const file = ev.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const img = new Image();
          img.onload = async () => {
            const maxSide = 1600;
            let w = img.width, h = img.height;
            const scale = Math.min(1, maxSide / Math.max(w, h));
            const cw = Math.round(w * scale), ch = Math.round(h * scale);
            const canvas = document.createElement('canvas');
            canvas.width = cw; canvas.height = ch;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, cw, ch);
            let meta = {};
            try {
              const exif = await parseEXIF(await file.arrayBuffer());
              const formatDate = (d) => {
                if (!d) return '';
                if (d instanceof Date) return d.toISOString().split('T')[0];
                const m = String(d).match(/^(\d{4}):?(\d{2}):?(\d{2})/);
                return m ? `${m[1]}-${m[2]}-${m[3]}` : '';
              };

              // ISO (multiple vendor fields)
              const iso = (exif?.ISO ?? exif?.ISOSpeedRatings ?? exif?.PhotographicSensitivity) || '';

              // Focal length (prefer exact, fallback to 35mm equivalent)
              let focal = '';
              if (typeof exif?.FocalLength === 'number') focal = `${exif.FocalLength} mm`;
              else if (typeof exif?.FocalLengthIn35mmFormat === 'number') focal = `${exif.FocalLengthIn35mmFormat} mm (35mm eq)`;
              else if (typeof exif?.FocalLengthIn35mmFormat === 'string') focal = exif.FocalLengthIn35mmFormat;

              // F‑stop (fallback from ApertureValue when FNumber missing)
              let fstop = '';
              if (typeof exif?.FNumber === 'number') fstop = `f/${exif.FNumber.toFixed(1)}`;
              else if (typeof exif?.ApertureValue === 'number') fstop = `f/${(Math.pow(Math.SQRT2, exif.ApertureValue)).toFixed(1)}`;

              // Exposure time (fallback from ShutterSpeedValue)
              let exposure = '';
              if (typeof exif?.ExposureTime === 'number') {
                exposure = exif.ExposureTime >= 1 ? `${exif.ExposureTime.toFixed(1)} s` : `1/${Math.round(1 / exif.ExposureTime)} s`;
              } else if (typeof exif?.ShutterSpeedValue === 'number') {
                const secs = 1 / Math.pow(2, exif.ShutterSpeedValue);
                exposure = secs >= 1 ? `${secs.toFixed(1)} s` : `1/${Math.round(1 / secs)} s`;
              }

              // Camera model (include make when present)
              const cameraModel = exif?.Model || [exif?.Make, exif?.Model].filter(Boolean).join(' ').trim();

              meta = {
                dateTaken: formatDate(exif?.DateTimeOriginal || exif?.CreateDate || exif?.ModifyDate || exif?.DateCreated),
                iso,
                focalLength: focal,
                fstop,
                exposureTime: exposure,
                cameraModel: cameraModel || ''
              };
              console.debug('EXIF parsed', exif);
            } catch (e) {
              console.warn('EXIF parse failed', e);
              // Fallbacks when EXIF unavailable
              const dt = file?.lastModified ? new Date(file.lastModified) : null;
              meta = {
                dateTaken: dt ? dt.toISOString().split('T')[0] : '',
                iso: '', focalLength: '', fstop: '', exposureTime: '',
                cameraModel: ''
              };
            }
            try {
              const out = canvas.toDataURL('image/jpeg', 0.85);
              cb(out, meta);
            } catch (e) {
              cb(reader.result, meta);
            }
          };
          img.src = reader.result;
        };
        reader.readAsDataURL(file);
      };
      inp.click();
    }

    function render() {
      const term = q.value.trim().toLowerCase();
      grid.innerHTML = '';
      let capturedCount = 0;
      let seenCount = 0;
      let total = 0;
      for (const sp of SPECIES) {
        if (term && !sp.name.toLowerCase().includes(term)) continue;
        total++;
        const hasPhoto = !!photos[sp.code];
        if (hasPhoto) { capturedCount++; }
        const isSeen = hasPhoto || seen.has(sp.code);
        if (isSeen) seenCount++;

        // Apply filter after counts so bubbles reflect counts for the current search
        const passesFilter = !filterMode ||
          (filterMode === 'captured' && hasPhoto) ||
          (filterMode === 'seen' && isSeen) ||
          (filterMode === 'missing' && !isSeen);
        if (!passesFilter) continue;

        const tile = document.createElement('div');
        tile.className = `tile ${hasPhoto ? 'seen' : (isSeen ? 'observed' : 'missing')}`;
        tile.title = (hasPhoto ? 'Seen (has photo): ' : 'Missing: ') + sp.name + ' — left‑click to add photo; right‑click for details';

        const card = document.createElement('div');
        card.className = 'card';

        // FRONT
        const front = document.createElement('div');
        front.className = 'face front';
        front.innerHTML = `
          <div class="content">${photos[sp.code] ? `<div class=\"photobox\" style=\"background-image:url('${photos[sp.code]}')\"></div>` : `<div class=\"sil\">🐦</div>`}</div>
          <div class=\"header\"><div class=\"left\"><div class=\"idx\">${String(sp.id).padStart(3, '0')}</div><div class=\"name\">${sp.name}</div></div></div>`;

        // Add icons to the front header (right side)
        { const header = front.querySelector('.header'); const icons = document.createElement('div'); icons.className = 'icons'; if (!hasPhoto) { icons.innerHTML += '<button class="iconbtn icon-eye" title="Mark as seen" aria-label="Mark as seen"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12z"></path><circle cx="12" cy="12" r="3.5"></circle></svg></button>'; } if (hasPhoto) { icons.innerHTML += '<button class="iconbtn icon-trash" title="Remove photo" aria-label="Remove photo"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M3 6h18M9 6l1-2h4l1 2M6 6l1 14h10L18 6"></path></svg></button>'; } icons.innerHTML += '<button class="iconbtn icon-info" title="More info" aria-label="More info"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01M11 12h2v6h-2z"></path></svg></button>'; header.appendChild(icons); }

        // BACK
        const back = document.createElement('div');
        back.className = 'face back';
        const meta = metadata[sp.code] || {};
        back.innerHTML = `
          <div class="top"><div class="title">${sp.name} · <span style="color:#6b6683">#${String(sp.id).padStart(3, '0')}</span></div>
          </div>
          <div class="body">
            ${hasPhoto ? `
            <div class="field"><span class="label">Date Taken:</span><span class="value">${meta.dateTaken || ''}</span></div>
            <div class="field"><span class="label">ISO:</span><span class="value">${meta.iso || ''}</span></div>
            <div class="field"><span class="label">Focal length:</span><span class="value">${meta.focalLength || ''}</span></div>
            <div class="field"><span class="label">F-stop:</span><span class="value">${meta.fstop || ''}</span></div>
            <div class="field"><span class="label">Exposure time:</span><span class="value">${meta.exposureTime || ''}</span></div>
            <div class="field"><span class="label">Camera Model:</span><span class="value">${meta.cameraModel || ''}</span></div>
            ` : ''}
          </div>`;

        card.appendChild(front); card.appendChild(back); tile.appendChild(card);

        // Interactions
        tile.addEventListener('click', (e) => {
          // Only on front clicks we allow photo add; ignore clicks on back controls
          if (tile.classList.contains('flipped')) return;
          pickFile((dataUrl, meta) => { photos[sp.code] = dataUrl; metadata[sp.code] = meta; save(); render(); });
        });
        tile.addEventListener('contextmenu', (e) => { e.preventDefault(); tile.classList.toggle('flipped'); });

        // Icon interactions (only for state toggling; no other behavior)
        const btnEye = card.querySelector('.icon-eye');
        if (btnEye) btnEye.addEventListener('click', (e) => {
          e.stopPropagation();
          if (seen.has(sp.code)) seen.delete(sp.code); else seen.add(sp.code);
          save(); render();
        });
        const btnTrash = card.querySelector('.icon-trash');
        if (btnTrash) btnTrash.addEventListener('click', (e) => {
          e.stopPropagation();
          delete photos[sp.code];
          delete metadata[sp.code];
          save(); render();
        });

        const btnInfo = card.querySelector('.icon-info');
        if (btnInfo) btnInfo.addEventListener('click', (e) => {
          e.stopPropagation();
          selectedCode = (selectedCode === sp.code) ? null : sp.code;
          renderDetails();
        });

        grid.appendChild(tile);
      }
      if (cCaptured) cCaptured.textContent = `Captured: ${capturedCount}`;
      cSeen.textContent = `Seen: ${seenCount}`;
      cMissing.textContent = `Missing: ${total - seenCount}`;
      cTotal.textContent = `Total: ${total}`;
      updateChips();
      renderDetails();
    }

    q.addEventListener('input', render);

    async function loadDefaultIfEmpty() {
      const isEmpty = (!photos || Object.keys(photos).length === 0)
        && (!metadata || Object.keys(metadata).length === 0)
        && (seen.size === 0);
      if (!isEmpty) return;
      try {
        const resp = await fetch(DEFAULT_DATA_URL, { cache: 'no-store' });
        if (!resp.ok) return;
        const data = await resp.json();
        if (data && typeof data === 'object') {
          photos = data.photos || {};
          metadata = data.metadata || {};
          seen = new Set(data.seen || []);
          save();
        }
      } catch (e) {
        console.debug('No default seed loaded', e);
      }
    }

    // Bubble filters (toggle on click, click Total to clear)
    if (cCaptured) cCaptured.addEventListener('click', () => { filterMode = filterMode === 'captured' ? null : 'captured'; render(); });
    if (cSeen) cSeen.addEventListener('click', () => { filterMode = filterMode === 'seen' ? null : 'seen'; render(); });
    if (cMissing) cMissing.addEventListener('click', () => { filterMode = filterMode === 'missing' ? null : 'missing'; render(); });
    if (cTotal) cTotal.addEventListener('click', () => { filterMode = null; render(); });

    // Export now includes photos + metadata + explicit seen set
    document.getElementById('exportBtn').onclick = () => {
      const payload = { photos, metadata, seen: Array.from(seen) };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'pokedex-data.json';
      a.click();
      URL.revokeObjectURL(a.href);
    };
    document.getElementById('importBtn').onclick = () => {
      const inp = document.createElement('input');
      inp.type = 'file'; inp.accept = 'application/json';
      inp.onchange = e => {
        const file = e.target.files[0]; if (!file) return;
        const r = new FileReader();
        r.onload = () => {
          try {
            const data = JSON.parse(r.result);
            photos = data.photos || {};
            metadata = data.metadata || {};
            seen = new Set(data.seen || []);
            save();
            render();
          } catch (err) { alert('Bad JSON'); }
        };
        r.readAsText(file);
      };
      inp.click();
    };

    (async function init() {
      await loadDefaultIfEmpty();
      render();
    })();
  </script>
</body>

</html>
